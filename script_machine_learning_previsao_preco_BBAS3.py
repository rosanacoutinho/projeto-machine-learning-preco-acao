# -*- coding: utf-8 -*-
"""Projeto_ML_precoAcao_BBAS3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JzRmHbsZ3P0yIp77jKibOy-NzA5ln1JP

#                       PUC MG - Pontificia Católica de Minas Gerais
##                  Pós-graduação Lato Sensu em Ciência de Dados e Big Data

                            TRABALHO DE CONCLUSÃO DE CURSO

TÍTULO : UTILIZANDO MACHINE LEARNING PARA PREVER O PREÇO DE UM ATIVO DE RENDA VARIÁVEL NA BOLSA DE VALORES

ALUNA : Rosana de Paula Coutinho Barros

Entrega: Fevereiro de 2022

## Importação das Bibliotecas Python
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2
from sklearn.model_selection import GridSearchCV
from sklearn.neural_network import MLPRegressor
from sklearn.preprocessing import MinMaxScaler
from sklearn import datasets, linear_model
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt
import seaborn as sns

import math 
import numpy as np
from  keras.models import Sequential 
from keras.layers import Dense, LSTM 

from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import cross_val_predict


# %matplotlib inline

#Importando dados do csv
df_bb = pd.read_csv("Series_acao_BBAS3_2009_2021.csv", delimiter=';', encoding='latin-1') 
df_bb

"""## Pré-Processamento dos dados"""

#verificar os tipos contidos no datafame
df_bb.dtypes

#altera o tipo do dado 
df_bb['data_pregao']=pd.to_datetime(df_bb['data_pregao'], format='%Y-%m-%d')

df_bb.dtypes

#criando novas colunas paras medias móveis
df_bb['mm5d']=df_bb['preco_fechamento'].rolling(5).mean()                       #media movel dos ultimos 5 dias
df_bb['mm21d']=df_bb['preco_fechamento'].rolling(21).mean()                     #media movel dos ultimos 21 dias

df_bb.head()

#Empurrando para frente os valores de preco de fechamento
df_bb['preco_fechamento'] = df_bb['preco_fechamento'].shift(-1)
df_bb.head()

df_bb.isnull().sum()

#retirando os dados nulos
df_bb.dropna(inplace=True)

df_bb.isnull().sum()

#reindexando o data frame
df_bb = df_bb.reset_index(drop=True)
df_bb

"""## Análise Exploratória dos Dados"""

df_bb.describe()

#seleciona um periodo menor para zoom na vizualizacao do grafico de histoprico de precos
df_bb_2017_2021 = df_bb.loc[df_bb['data_pregao'] >= '2017-01-01']
df_bb_2017_2021.set_index('data_pregao', inplace=True)

#Criando um dataFrame cujo o index seja a propria data para a plotagem do grafico de historico
df_grafico = df_bb.copy()
df_grafico.set_index('data_pregao', inplace=True)

#Plotagem da serie historica de todo o periodo 
plt.figure(figsize=(15,5))
#df_grafico['preco_maximo'].plot(label='Maximo', color='green')
#df_grafico['preco_minimo'].plot(label='Minimo', color='red')
df_grafico['preco_fechamento'].plot(label='Fechamento', color='blue')
plt.ylabel('Preço')
plt.xlabel('Período')
plt.title('Histórico de Preços da BBAS3')
plt.legend();

#Plotagem da serie historica a partir de 2017
plt.figure(figsize=(15,5))
#df_bb_2017_2021['preco_maximo'].plot(label='Maximo', color='green')
#df_bb_2017_2021['preco_minimo'].plot(label='Minimo', color='red')
df_bb_2017_2021['preco_fechamento'].plot(label='Fechamento', color='blue')
plt.ylabel('Preço')
plt.xlabel('Período')
plt.title('Histórico de Preços da BBAS3')
plt.legend();

#Plotagem da variacao de preco 
variacao_bbas3 = abs(df_grafico['preco_abertura'] - df_grafico['preco_fechamento'])
plt.figure(figsize=(15,5))
variacao_bbas3.plot(label='Variacao de Preço', color='red')
plt.ylabel('Variacao Preço')
plt.xlabel('Período')
plt.title('Variacao de Preços diario da BBAS3')

#Retorna a data com a maior variacao entre o preco de abertura e fechamento
maxima_variacao_bbas3 = variacao_bbas3.values.argmax()
maximo_valor_bbas3 = variacao_bbas3.values[maxima_variacao_bbas3,]
variacao_bbas3[variacao_bbas3.values==maximo_valor_bbas3]

#Plotagem do volume negociado no periodo 
plt.figure(figsize=(15,5))
df_grafico['volume_negocios'].plot(label='Volume', color='blue')
plt.ylabel('Volume')
plt.xlabel('Período')
plt.title('Volume negociado da BBAS3')

#Plota um histograma da distribuicao da BBAS3 utilizando precos de fechamento do dia
plt.figure(figsize=(15,5))

sns.set_context('notebook', font_scale=1.5, rc={ 'font.size' : 20, 'axes.labesize':18 } )
sns.rugplot(df_grafico['preco_fechamento'], color='red')
sns.distplot(df_grafico['preco_fechamento'], color='green')
sns.set_style('darkgrid')
plt.title('Distribuicao do preco de fechamento da BBAS3')

#Retorna a data com maior volume de negociacao
maxima_volume_negociacao = df_grafico['volume_negocios'].argmax()
df_grafico.iloc[maxima_volume_negociacao,:]

"""## Escolha das Melhores Features e Normalização os dados
 
"""

#Definindo a quantidade de linhas para cada utilizacao

qtd_linhas = len(df_bb)

qtd_linhas_treino= round(.70 * qtd_linhas)
qtd_linhas_teste= round(.28 * qtd_linhas)
qtd_linhas_validacao = round(.02 * qtd_linhas)

info = (
    f"linhas treino= 0:{qtd_linhas_treino}"
    f" linhas teste= {qtd_linhas_treino}:{qtd_linhas_treino + qtd_linhas_teste -1}"
    f" linhas validação= {qtd_linhas_treino + qtd_linhas_teste}:{qtd_linhas }"
)

info

print("quantidade linhas treino {}".format(qtd_linhas_treino))
print("quantidade linhas teste {}".format(qtd_linhas_teste))
print("quantidade linhas validacao {}".format(qtd_linhas_validacao))

#definindo as features e as labels
features = df_bb.drop(['sigla_acao', 'nome_acao', 'data_pregao', 'preco_fechamento'], 1)
labels = df_bb['preco_fechamento']
features

#Escolhendo as melhores features com SelectKBest
features_list = ('preco_abertura','preco_max','preco_minimo','qtd_negocios','volume_negocios','mm5d','mm21d')

k_best_features = SelectKBest(k='all')
k_best_features.fit_transform(features, labels)
k_best_features_scores = k_best_features.scores_
raw_pairs = zip(features_list[1:], k_best_features_scores)
ordered_pairs = list(reversed(sorted(raw_pairs, key=lambda x: x[1])))

k_best_features_final = dict(ordered_pairs[:15])
best_features = k_best_features_final.keys()
print ('')
print ("Melhores features:")
print (k_best_features_final)

#criando um df com as features selecionadas
features = df_bb.loc[:,['preco_maximo','preco_minimo','volume_negocios','qtd_negocios']]

#Cria os datasets de treino e teste

x_train = features[:qtd_linhas_treino]
x_test = features[qtd_linhas_treino:qtd_linhas_treino + qtd_linhas_teste -1]

y_train = labels[:qtd_linhas_treino]
y_test = labels[qtd_linhas_treino:qtd_linhas_treino + qtd_linhas_teste -1]

x_validacao = features.tail(64) #2% das linhas do dataset inteiro

#Normalizando os datasets de treino, teste e validação com MinMaxScaler

scaler = MinMaxScaler()

x_train_scale = scaler.fit_transform(x_train)  
x_test_scale  = scaler.transform(x_test)  
x_validacao_scale = scaler.transform(x_validacao)

"""## Modelo de Regressão Linear do SKlearn  (com cross-validation)


"""

#construcao e treinamento usando regressao linear do SKlearn

lr = linear_model.LinearRegression()   
lr.fit(x_train_scale, y_train)    
pred= lr.predict(x_test_scale)

score_lr = lr.score(x_test_scale,y_test )
print("Score: %.3f%%" % (score_lr * 100.0))

#executando o modelo Linear para obter as predicoes 
pred=lr.predict(x_validacao_scale)

#dados reais X dados previstos pelo modelo
data_pregao_full = df_bb['data_pregao']
data_pregao=data_pregao_full.tail(64)
res_full=df_bb['preco_fechamento']
res=res_full.tail(64)
df_comparativo_lr =pd.DataFrame({'data_pregao':data_pregao, 'real':res, 'previsao':pred})
df_comparativo_lr.set_index('data_pregao', inplace=True)
df_comparativo_lr['distancia']= abs( df_comparativo_lr['real'] - df_comparativo_lr['previsao'] ) 

print(df_comparativo_lr)

"""**Validacao Cruzada** 

"""

#definindo os dados de entreada e saida 

x_entradas = df_bb.loc[:,['preco_maximo','preco_minimo','volume_negocios','qtd_negocios']]
y_target = df_bb.loc[:,['preco_fechamento']]
x = x_entradas.to_numpy()
y = y_target.to_numpy()

#construcao da maquina preditiva 

num_folds = 4
seed = 7 
kfold = KFold(num_folds, shuffle=True, random_state= seed)

modelo_lr_vc = linear_model.LinearRegression()  

#Treinando a maquina com validacao cruzada 
score_lr_vc = cross_val_score(modelo_lr_vc, x, y, cv = kfold)


print("Score: %.3f%%" % (score_lr_vc.mean() * 100.0))

#obtendo as predicoes 
new_pred_lr_vc = cross_val_predict(modelo_lr_vc, x, y, cv=kfold)
new_pred_lr_vc= new_pred_lr_vc[-64:]
new_pred_lr_vc = np.reshape(new_pred_lr_vc, (64,))

#dados reais X dados previstos pelo modelo
data_pregao_full = df_bb['data_pregao']
data_pregao=data_pregao_full.tail(64)
res_full=df_bb['preco_fechamento']
res =res_full.tail(64)
df_comparativo_lr_vc =pd.DataFrame({'data_pregao':data_pregao, 'real':res, 'previsao':new_pred_lr_vc})
df_comparativo_lr_vc.set_index('data_pregao', inplace=True)
df_comparativo_lr_vc['distancia']= abs(df_comparativo_lr_vc['real'] - df_comparativo_lr_vc['previsao']) 

print(df_comparativo_lr_vc)

#root mean squared error (RMSE)  - SEM validacao cruzada
rmse_lr = np.sqrt( np.mean(res - pred)**2 )
rmse_lr

#root mean squared error (RMSE)  - COM validacao cruzada
rmse_lr = np.sqrt( np.mean(res - new_pred_lr_vc)**2 )
rmse_lr

plt.figure(figsize=(16,8))
plt.title('Preço BBAS3 - Modelo de Regressao Linear do SKLearn')
plt.plot(df_comparativo_lr_vc['real'], label="real", color='blue', marker='o')
plt.plot(df_comparativo_lr_vc['previsao'], label="previsao", color='red', marker='o')
plt.xlabel('Data pregão')
plt.ylabel('Preco de Fechamento')
leg = plt.legend()

"""## Modelo de Rede Neural MLPRegressor do SKLearn  (com cross-validation)

Multi-layer Perceptron (MLP) is a supervised learning algorithm
"""

#rede neural
rn = MLPRegressor(max_iter=2000)
rn.fit(x_train_scale, y_train)
pred = rn.predict(x_test_scale)
cd = rn.score(x_test_scale, y_test) #acuracia 

print("score: %.3f%%" % (cd * 100.0))

pred_rn = rn.predict(x_validacao_scale)

#Dataframe comparativo com os dados reais X dados previstos pelo modelo

data_pregao_full = df_bb['data_pregao']
data_pregao=data_pregao_full.tail(64)
res_full=df_bb['preco_fechamento']
res =res_full.tail(64)
df_comparativo =pd.DataFrame({'data_pregao':data_pregao, 'real':res, 'previsao':pred_rn})
df_comparativo.set_index('data_pregao', inplace=True)
df_comparativo['distancia']=   abs(df_comparativo['real'] - df_comparativo['previsao'] )

print(df_comparativo)

"""**Validacao Cruzada** 


"""

#definindo os dados de entreada e saida 

x_entradas = df_bb.loc[:,['preco_maximo','preco_minimo','volume_negocios','qtd_negocios']]
y_target = df_bb.loc[:,['preco_fechamento']]

scaler = MinMaxScaler()

x = scaler.fit_transform(x_entradas) 
y = y_target.to_numpy()

y = np.reshape(y, (3193,))

# construcao da maquina preditiva

num_folds = 4 
seed = 7 
kfold = KFold(num_folds, shuffle=True, random_state= seed)


model_rn_vc = MLPRegressor(max_iter=2000)
acuracia = cross_val_score(model_rn_vc, x, y, cv = kfold)


print("score: %.3f%%" % (acuracia.mean() * 100.0))

#obtendo as predicoes 
new_pred_rn_vc = cross_val_predict(model_rn_vc, x, y, cv=kfold)
new_pred_rn_vc= new_pred_rn_vc[-64:]

data_pregao_full = df_bb['data_pregao']
data_pregao=data_pregao_full.tail(64)
res_full=df_bb['preco_fechamento']
res=res_full.tail(64)
df_comparativo_rn =pd.DataFrame({'data_pregao':data_pregao, 'real':res, 'previsao':new_pred_rn_vc})
df_comparativo_rn.set_index('data_pregao', inplace=True)
df_comparativo_rn['distancia']=  abs(df_comparativo_rn['real'] - df_comparativo_rn['previsao'] )


print(df_comparativo_rn)

#root mean squared error (RMSE) - SEM validacao cruzada

rmse_rn = np.sqrt( np.mean(res - pred_rn)**2 )
rmse_rn

#root mean squared error (RMSE)  - COM validacao cruzada
 
rmse_rn = np.sqrt( np.mean(res - new_pred_rn_vc)**2 )
rmse_rn

plt.figure(figsize=(16,8))
plt.title('Preço BBAS3 - Modelo de Rede Neural MLPRegressor do SKLearn')
plt.plot(df_comparativo_rn['real'], label="real", color='blue', marker='o')
plt.plot(df_comparativo_rn['previsao'], label="previsao", color='red', marker='o')
plt.xlabel('Data pregão')
plt.ylabel('Preco de Fechamento')
leg = plt.legend()

"""## Modelo de Rede Neural LSTM (Long-Short Term Memory )

"""

df_lstm = df_bb.copy()
df_lstm.set_index('data_pregao', inplace=True)
df_lstm

#defininda a quantidade para dados de treinamento 
data = df_lstm.filter(['preco_fechamento'])
dataset = data.values 
training_data_len = math.ceil( len(dataset) * .7 )
training_data_len

#normalizacao 
scaler2 = MinMaxScaler(feature_range=(0,1))
scaled_data= scaler2.fit_transform(dataset)
scaled_data

#criando o dataset de treinamento 
train_data_lstm =scaled_data[0:training_data_len, :]

#spliting os dados em x_train e y_train 
x_train_lstm =[]
y_train_lstm =[] 

for i in range(64, len(train_data_lstm)):
  x_train_lstm.append(train_data_lstm[i-64:i,0])
  y_train_lstm.append(train_data_lstm[i,0])
  if i<=64:
    print(x_train_lstm)
    print(y_train_lstm)
    print()

#converter o x_train e o y_train em um numpy array
x_train_lstm, y_train_lstm = np.array(x_train_lstm), np.array(y_train_lstm)

#reshape os dados
x_train_lstm = np.reshape(x_train_lstm, (x_train_lstm.shape[0], x_train_lstm.shape[1],1)) #64, 1
x_train_lstm.shape

#criando dataset de teste 
test_data = scaled_data[training_data_len - 64: , :]

#spliting os dados em x_test e y_test 
x_test_lstm =  [] 
y_test_lstm = dataset[training_data_len: , :]

for i in range(64, len(test_data)):
  x_test_lstm.append(test_data[i-64:i,0])

#converter o x_train e o y_train em um numpy array
x_test_lstm = np.array(x_test_lstm)

#reshape os dados
x_test_lstm = np.reshape(x_test_lstm, (x_test_lstm.shape[0], x_test_lstm.shape[1],1)) 
x_test_lstm.shape

#Criando o Modelo LSTM

lstm_model = Sequential()
lstm_model.add(LSTM(50, return_sequences=True, input_shape =(x_train_lstm.shape[1],1))) #64, 1
lstm_model.add(LSTM(50, return_sequences=False))
lstm_model.add(Dense(25))
lstm_model.add(Dense(1))

#Compilando o modelo

lstm_model.compile(optimizer='adam', loss='mean_squared_error')

#treinamento do modelo LSTM

lstm_model.fit(x_train_lstm, y_train_lstm, batch_size=1, epochs=1)

#previsoes 
pred_lstm = lstm_model.predict(x_test_lstm)
pred_lstm = scaler2.inverse_transform(pred_lstm)

#data frame comparativo do dados reais X dados previstos pelo modelo
data_pregao_full = df_bb['data_pregao']
data_pregao=data_pregao_full.tail(64)
data_df_lstm_full =pd.Series( df_lstm['preco_fechamento'].values )
data_df_lstm =data_df_lstm_full.tail(64)
res_lstm_full=  pred_lstm 
ress_lstm = res_lstm_full[-64:] #.tail(64)
data_df_lstm_series = pd.Series(data_df_lstm)

df_comparativo_lstm =pd.DataFrame({'data_pregao':data_pregao, 'real':data_df_lstm}) #, 'previsao':data_pregao})
df_comparativo_lstm['previsao'] = ress_lstm
df_comparativo_lstm.set_index('data_pregao', inplace=True)

df_comparativo_lstm['distancia']= abs(df_comparativo_lstm['real'] - df_comparativo_lstm['previsao'])


print(df_comparativo_lstm)

#root mean squared error (RMSE)

rmse_lstm = np.sqrt( np.mean(pred_lstm - y_test_lstm)**2 )
rmse_lstm

plt.figure(figsize=(16,8))
plt.title('Preço BBAS3 - Modelo de Rede Neural LSTM')
plt.plot(df_comparativo_lstm['real'], label="real", color='blue', marker='o')
plt.plot(df_comparativo_lstm['previsao'], label="previsao", color='red', marker='o')
plt.xlabel('Data pregão')
plt.ylabel('Preco de Fechamento')
leg = plt.legend()

"""## Comparação dos modelos

"""

#dataframe comparativo 
comparacao_3_modelos = pd.DataFrame()
comparacao_3_modelos['real'] = df_comparativo_lr_vc['real']
comparacao_3_modelos['previsao_regressao_linear'] = df_comparativo_lr_vc['previsao']
comparacao_3_modelos['previsao_rede_neural'] = df_comparativo_rn['previsao']
comparacao_3_modelos['previsao_lstm'] = df_comparativo_lstm['previsao']
comparacao_3_modelos = comparacao_3_modelos.loc[:,['real','previsao_regressao_linear','previsao_rede_neural','previsao_lstm']]

comparacao_3_modelos

print("RMSE modelo Regressao Linear        : %.4f" % rmse_lr)
print("RMSE modelo Rede Neural Multicamada : %.4f" % rmse_rn)
print("RMSE modelo Rede Neural LSTM        : %.4f"  % rmse_lstm)

plt.figure(figsize=(16,8))
plt.title('Comparando a performance dos modelos')
plt.plot(comparacao_3_modelos['real'], label="real", color='blue', marker='o')
plt.plot(comparacao_3_modelos['previsao_regressao_linear'], label="Reg Linear", color='red', marker='o')
plt.plot(comparacao_3_modelos['previsao_rede_neural'], label="Rede Neural", color='yellow', marker='o')
plt.plot(comparacao_3_modelos['previsao_lstm'], label="Lstm", color='green', marker='o')
plt.xlabel('Data pregão')
plt.ylabel('Preco de Fechamento')
leg = plt.legend()